/* -*- Mode: C; c-basic-offset: 4 -*- */
%%
headers
#include <Python.h>
#include "pygobject.h"
#include "gtkmydrawwidget.h"
#include "gtkmybrush.h"
#include "gtkmysurface.h"
#include "gtkmysurfaceold.h"
%%
modulename mydrawwidget
%%
import gtk.DrawingArea as PyGtkDrawingArea_Type
import gobject.GObject as PyGObject_Type
import gtk.gdk.Pixbuf as PyGdkPixbuf_Type
%%
ignore-glob
  *_get_type
ignore brush_stroke_to 
ignore brush_reset 
ignore gtk_my_surface_old_get_nonwhite_region  
%%
override gtk_my_draw_widget_stop_recording noargs
static PyObject *
_wrap_gtk_my_draw_widget_stop_recording (PyGObject *self)
{
    PyObject * result;
    GString * s;
    s = gtk_my_draw_widget_stop_recording (GTK_MY_DRAW_WIDGET(self->obj));
    if (!s) {
        PyErr_SetString(PyExc_ValueError, "called stop_recording before start_recording");
        return NULL;
    }
    // this will memcpy() the data
    result = PyString_FromStringAndSize((char*)s->str, s->len);
    g_string_free(s, TRUE);
    return result;
}
%%
override gtk_my_draw_widget_replay
static PyObject *
_wrap_gtk_my_draw_widget_replay(PyGObject *self, PyObject *args)
{
    GString s;
    int immediately;
    int len;
    if (!PyArg_ParseTuple(args, "s#i:GtkMyDrawWidget.replay", &(s.str), &len, &immediately))
        return NULL;
    s.len = len; // cast int to gsize_t
    // returns pointer to python memory, so it must not be free()d
    s.allocated_len = 0; // should never get accessed
    // s is a read-only GString now, and will be invalid after this call
    gtk_my_draw_widget_replay(GTK_MY_DRAW_WIDGET(self->obj), &s, immediately);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_my_brush_get_state noargs
static PyObject *
_wrap_gtk_my_brush_get_state  (PyGObject *self)
{
    PyObject * result;
    GString * s;
    s = gtk_my_brush_get_state (GTK_MY_BRUSH(self->obj));
    // this will memcpy() the data
    result = PyString_FromStringAndSize((char*)s->str, s->len);
    g_string_free(s, TRUE);
    return result;
}
%%
override gtk_my_brush_set_state
static PyObject *
_wrap_gtk_my_brush_set_state (PyGObject *self, PyObject *args)
{
    GString s;
    int len;
    if (!PyArg_ParseTuple(args, "s#:GtkMyBrush.set_state", &(s.str), &len))
        return NULL;
    s.len = len; // cast int to gsize_t
    // returns pointer to python memory, so it must not be free()d
    s.allocated_len = 0; // should never get accessed
    // s is a read-only GString now, and will be invalid after this call
    gtk_my_brush_set_state (GTK_MY_BRUSH (self->obj), &s);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_my_brush_get_stroke_bbox
static PyObject *
_wrap_gtk_my_brush_get_stroke_bbox (PyGObject *self, PyObject *args)
{
    PyObject * list;
    list = PyTuple_New((int)4);
    
    Rect r = gtk_my_brush_get_stroke_bbox (GTK_MY_BRUSH(self->obj));

    int i = 0;
    PyTuple_SetItem(list, i++, PyInt_FromLong(r.x));
    PyTuple_SetItem(list, i++, PyInt_FromLong(r.y));
    PyTuple_SetItem(list, i++, PyInt_FromLong(r.w));
    PyTuple_SetItem(list, i++, PyInt_FromLong(r.h));

    return list;
}
