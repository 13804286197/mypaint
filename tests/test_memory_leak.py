#!/usr/bin/env python
from numpy import *
from time import time
import sys, os, gc

os.chdir(os.path.dirname(sys.argv[0]))
sys.path.insert(0, '..')

from lib import mypaintlib, tiledsurface, brush, document, command, helpers
import guicontrol

# loadtxt is known to leak memory, thus we run it only once
# http://projects.scipy.org/numpy/ticket/1356
painting30sec_events = loadtxt('painting30sec.dat.gz')

LEAK_EXIT_CODE = 33

def mem():
    gc.collect()
    return int(open('/proc/self/statm').read().split()[0])

def check_garbage(msg = 'uncollectable garbage left over from previous tests'):
    gc.collect()
    garbage = []
    for obj in gc.garbage:
        # ignore garbage generated by numpy loadtxt command
        if hasattr(obj, 'filename') and obj.filename == 'painting30sec.dat.gz':
            continue
        garbage.append(obj)
    assert not garbage, 'uncollectable garbage left over from previous tests: %s' % garbage

def leakTest_generic(func):
    print 'memory leak test', func.__name__
    check_garbage()

    doc = document.Document()
    #gc.set_debug(gc.DEBUG_LEAK)

    max_mem = 0
    max_mem_stable = 0
    no_leak = False
    m1 = 0
    for i in range(options.max_iterations):
        func(doc, i)
        if options.debug:
            if i == 3:
                check_garbage()
                helpers.record_memory_leak_status()
            if i == 4 or i == 5:
                helpers.record_memory_leak_status(print_diff=True)
        m2 = mem()
        print 'iteration %02d/%02d: %d pages used (%+d)' % (i+1, options.max_iterations, m2, m2-m1)
        m1 = m2
        if m2 > max_mem:
            max_mem = m2
            max_mem_stable = 0
        else:
            max_mem_stable += 1
            if max_mem_stable == options.required:
                print 'maximum was stable for', max_mem_stable, 'iterations'
                no_leak = True
                break

    #import objgraph
    #from lib import strokemap
    #objgraph.show_refs(doc)
    #sys.exit(0)

    # note: if gc.DEBUG_LEAK is enabled above this is expected to fail
    check_garbage()

    if no_leak:
        print 'no leak found'
    else:
        print 'memory leak in ' + func.__name__
        sys.exit(LEAK_EXIT_CODE)


all_tests = {}
def leaktest(test_func):
    "decorator to declare leak test functions"
    all_tests[test_func.__name__] = test_func
    return test_func

all_tests = {}
def leaktest_gui(test_func):
    "decorator to declare leak test functions using GUI"
    def testfunc_modified(doc, iteration):
        gui = guicontrol.GUI()

    all_tests[test_func.__name__] = test_func
    test_func = test_performance.with_gui_setup(test_func)
    return test_func

#@leaktest
def provoke_leak(doc, iteration):
    # note: interestingly this leaky only shows in the later iterations
    #       (and very small leaks might not be detected)
    setattr(gc, 'my_test_leak_%d' % iteration, zeros(50000))

@leaktest
def noleak(doc, iteration):
    setattr(gc, 'my_test_leak', zeros(50000))

@leaktest
def document_alloc(doc, iteration):
    document.Document()

@leaktest
def surface_alloc(doc, iteration):
    tiledsurface.Surface()

@leaktest_gui
def scroll_nozoom(gui, iteration):
    yield wait_for_idle
    def f(): pass
    for res in scroll(f):
        yield res


def paint(doc):
    events = painting30sec_events
    t_old = events[0][0]
    for i, (t, x, y, pressure) in enumerate(events):
        dtime = t - t_old
        t_old = t
        doc.stroke_to(dtime, x, y, pressure)

@leaktest
def paint_and_clear(doc, iteration):
    paint(doc)
    doc.clear()

@leaktest
def repeated_saving(doc, iteration):
    if iteration == 0:
        paint(doc)
    doc.save('test_leak.ora')
    doc.save('test_leak.png')
    doc.save('test_leak.jpg')

@leaktest
def repeated_loading(doc, iteration):
    doc.load('bigimage.ora')

@leaktest
def paint_save_clear(doc, iteration):
    paint(doc)
    doc.save('test_leak.ora')
    doc.clear()


if __name__ == '__main__':
    from optparse import OptionParser
    parser = OptionParser('usage: %prog [options] [test1 test2 test3 ...]')
    parser.add_option('-a', '--all', action='store_true', default=False, 
                      help='run all tests')
    parser.add_option('-l', '--list', action='store_true', default=False,
                    help='list all available tests')
    parser.add_option('-d', '--debug', action='store_true', default=False,
                      help='print leak analysis (slow)')
    parser.add_option('-e', '--exit', action='store_true', default=False,
                      help='exit at first error')
    parser.add_option('-r', '--required', type='int', default=15,
                      help='good iterations required (default: 15)')
    parser.add_option('-m', '--max-iterations', type='int', default=100,
                      help='maximum number of iterations (default: 100)')
    options, tests = parser.parse_args()

    if options.list:
        for name in sorted(all_tests.keys()):
            print name
        sys.exit(0)

    if options.required >= options.max_iterations:
        print 'requiring more good iterations than the iteration limit makes no sense'
        sys.exit(1)

    if not tests:
        if options.all:
            tests = list(all_tests)
        else:
            parser.print_help()
            sys.exit(1)

    for t in tests:
        if t not in all_tests:
            print 'Unknown test:', t
            sys.exit(1)

    results = []
    for t in tests:
        child_pid = os.fork()
        if not child_pid:
            print '---'
            print 'running test "%s"' % t
            print '---'
            leakTest_generic(all_tests[t])
            sys.exit(0)

        pid, status = os.wait()
        exitcode = os.WEXITSTATUS(status)
        if options.exit and exitcode != 0:
            sys.exit(1)
        results.append(exitcode)

    everything_okay=True
    print
    print '=== SUMMARY ==='
    for t, exitcode in zip(tests, results):
        if exitcode == 0:
            print t, 'OK'
        else:
            everything_okay=False
            if exitcode == LEAK_EXIT_CODE:
                print t, 'LEAKING'
            else:
                print t, 'EXCEPTION'
    if not everything_okay:
        sys.exit(1)
