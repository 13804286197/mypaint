#!/usr/bin/env python
from numpy import *
from time import time
import sys, os, gc

os.chdir(os.path.dirname(sys.argv[0]))
sys.path.insert(0, '..')

from lib import mypaintlib, tiledsurface, brush, document, command, helpers

# loadtxt is known to leak memory, thus we run it only once
# http://projects.scipy.org/numpy/ticket/1356
painting30sec_events = loadtxt('painting30sec.dat.gz')

LEAK_EXIT_CODE = 33

def mem():
    gc.collect()
    return int(open('/proc/self/statm').read().split()[0])

def check_garbage(msg = 'uncollectable garbage left over from previous tests'):
    gc.collect()
    garbage = []
    for obj in gc.garbage:
        # ignore garbage generated by numpy loadtxt command
        # http://projects.scipy.org/numpy/ticket/1356
        if hasattr(obj, 'filename') and obj.filename == 'painting30sec.dat.gz':
            continue
        garbage.append(obj)
    assert not garbage, 'uncollectable garbage left over from previous tests: %s' % garbage

def leakTest_generic(func):
    print 'memory leak test', func.__name__
    check_garbage()

    doc = document.Document()
    #gc.set_debug(gc.DEBUG_LEAK)

    m = []
    N = 21
    for i in range(N):
        func(doc, i)
        if options.debug:
            if i == 3:
                check_garbage()
                helpers.record_memory_leak_status()
            if i == 4:
                helpers.record_memory_leak_status(print_diff=True)
        m2 = mem()
        m.append(m2)
        print 'iteration %02d/%02d: %d pages used' % (i+1, N, m2)

    #import objgraph
    #from lib import strokemap
    #objgraph.show_refs(doc)
    #sys.exit(0)

    # note: if gc.DEBUG_LEAK is enabled above this is expected to fail
    check_garbage()

    print m
    # we also have oscillations for some tests
    cmp_1st = m[N*1/3:N*2/3]
    cmp_2nd = m[N*2/3:N*3/3]
    diff = abs(max(cmp_1st) - max(cmp_2nd))
    #if diff == 1:
    #    print 'FIXME: known minor leak ignored'
    #else:
    if diff != 0:
        print 'looks like a memory leak in ' + func.__name__
        sys.exit(LEAK_EXIT_CODE)
    print 'no leak found'


all_tests = {}
def leaktest(test_func):
    "decorator to declare leak test functions"
    all_tests[test_func.__name__] = test_func
    return test_func

@leaktest
def surface_alloc(doc, iteration):
    tiledsurface.Surface()

@leaktest
def paint(doc, iteration):
    events = painting30sec_events
    t_old = events[0][0]
    for i, (t, x, y, pressure) in enumerate(events):
        dtime = t - t_old
        t_old = t
        doc.stroke_to(dtime, x, y, pressure)

@leaktest
def paint_and_clear(doc, iteration):
    paint(doc)
    doc.clear()

@leaktest
def repeated_saving(doc, iteration):
    if iteration == 0:
        paint(doc)
    doc.save('test_leak.ora')
    doc.save('test_leak.png')
    doc.save('test_leak.jpg')

@leaktest
def repeated_loading(doc, iteration):
    doc.load('bigimage.ora')

@leaktest
def paint_save_clear(doc, iteration):
    paint(doc)
    doc.save('test_leak.ora')
    doc.clear()

@leaktest
def provoke_leak(doc, iteration):
    # note: interestingly this leaky only shows in the later iterations
    #       (and smaller leaks will not be detected)
    setattr(gc, 'my_test_leak_%d' % iteration, zeros(50000))

def leakTest_slow():

    #leakTest_generic(provoke_leak)
    leakTest_generic(paint_and_clear)
    leakTest_generic(repeated_saving)
    leakTest_generic(repeated_loading)
    leakTest_generic(paint_save_clear)


if __name__ == '__main__':
    from optparse import OptionParser
    parser = OptionParser('usage: %prog [options] [test1 test2 test3 ...]')
    parser.add_option('-a', '--all', action='store_true', default=False, 
                      help='run all tests')
    parser.add_option('-l', '--list', action='store_true', default=False,
                    help='list all available tests')
    parser.add_option('-d', '--debug', action='store_true', default=False,
                      help='print leak analysis (slow)')
    parser.add_option('-e', '--exit', action='store_true', default=False,
                      help='exit at first error')
    options, tests = parser.parse_args()

    if options.list:
        for name in sorted(all_tests.keys()):
            print name
        sys.exit(0)

    if not tests:
        if options.all:
            tests = list(all_tests)
        else:
            parser.print_help()
            sys.exit(1)

    for t in tests:
        if t not in all_tests:
            print 'Unknown test:', t
            sys.exit(1)

    results = []
    for t in tests:
        child_pid = os.fork()
        if not child_pid:
            print '---'
            print 'running test "%s"' % t
            print '---'
            leakTest_generic(all_tests[t])
            sys.exit(0)

        pid, status = os.wait()
        exitcode = os.WEXITSTATUS(status)
        if options.exit and exitcode != 0:
            sys.exit(1)
        results.append(exitcode)

    everything_okay=True
    print
    print '=== SUMMARY ==='
    for t, exitcode in zip(tests, results):
        if exitcode == 0:
            print t, 'OK'
        else:
            everything_okay=False
            if exitcode == LEAK_EXIT_CODE:
                print t, 'LEAKING'
            else:
                print t, 'EXCEPTION'
    if not everything_okay:
        sys.exit(1)
